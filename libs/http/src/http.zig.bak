const std = @import("std");

// Connection and timeout settings for HTTP client
pub const ConnectionSettings = struct {
    connect_timeout_ms: u64 = 30000, // 30 seconds to establish connection
    request_timeout_ms: u64 = 120000, // 2 minutes for full request
    read_timeout_ms: u64 = 60000, // 1 minute between reads (for streaming)
    keep_alive: bool = false,
};

/// A simple wrapper around std.http.Client with timeout configuration
pub const Client = struct {
    allocator: std.mem.Allocator,
    client: std.http.Client,
    settings: ConnectionSettings,

    pub fn init(allocator: std.mem.Allocator) !Client {
        return try initWithSettings(allocator, .{});
    }

    pub fn initWithSettings(allocator: std.mem.Allocator, settings: ConnectionSettings) !Client {
        var client = std.http.Client{
            .allocator = allocator,
        };
        // This is crucial for Zig 0.15.2+ to handle HTTPS requests correctly on macOS and other platforms.
        // It scans system-standard locations for CA certificates.
        try client.ca_bundle.rescan(allocator);

        return .{
            .allocator = allocator,
            .client = client,
            .settings = settings,
        };
    }

    pub fn deinit(self: *Client) void {
        self.client.deinit();
    }

    pub const Response = struct {
        status: std.http.Status,
        body: []u8,
        allocator: std.mem.Allocator,

        pub fn deinit(self: *Response) void {
            self.allocator.free(self.body);
        }
    };

    pub fn post(self: *Client, url: []const u8, headers: []const std.http.Header, body: []const u8) !Response {
        const uri = try std.Uri.parse(url);

        std.debug.print("[HTTP] POST to {s} (body: {d} bytes)...\n", .{ url, body.len });

        var response_body = std.Io.Writer.Allocating.init(self.allocator);
        defer response_body.deinit();

        const result = try self.client.fetch(.{
            .location = .{ .uri = uri },
            .method = .POST,
            .extra_headers = headers,
            .payload = body,
            .response_writer = &response_body.writer,
            .keep_alive = self.settings.keep_alive,
        });

        return Response{
            .status = result.status,
            .body = try response_body.toOwnedSlice(),
            .allocator = self.allocator,
        };
    }

    pub fn get(self: *Client, url: []const u8, headers: []const std.http.Header) !Response {
        const uri = try std.Uri.parse(url);

        var response_body = std.Io.Writer.Allocating.init(self.allocator);
        defer response_body.deinit();

        const result = try self.client.fetch(.{
            .location = .{ .uri = uri },
            .method = .GET,
            .extra_headers = headers,
            .response_writer = &response_body.writer,
            .keep_alive = self.settings.keep_alive,
        });

        return Response{
            .status = result.status,
            .body = try response_body.toOwnedSlice(),
            .allocator = self.allocator,
        };
    }

    pub fn postStream(self: *Client, url: []const u8, headers: []const std.http.Header, body: []const u8) !std.http.Client.Request {
        const uri = try std.Uri.parse(url);

        std.debug.print("[HTTP] POST stream to {s} (body: {d} bytes)...\n", .{ url, body.len });

        var req = try self.client.request(.POST, uri, .{
            .extra_headers = headers,
            .keep_alive = self.settings.keep_alive,
            .version = .@"HTTP/1.1",
        });
        errdefer req.deinit();

        req.transfer_encoding = .{ .content_length = body.len };

        var body_buf: [4096]u8 = undefined;
        var body_writer = try req.sendBody(&body_buf);
        try body_writer.writer.writeAll(body);
        try body_writer.end();

        std.debug.print("[HTTP] Stream request sent, awaiting response headers...\n", .{});

        return req;
    }
};

test "Client: init and deinit" {
    const allocator = std.testing.allocator;
    var client = try Client.init(allocator);
    defer client.deinit();
    try std.testing.expect(client.allocator.ptr == allocator.ptr);
}
